Engineering experience
======================

  - What kinds of software projects have you worked on before? Which operating systems, development environments, languages, databases?
    * I have professionally worked on projects using the CodeIgniter framework and Javascript, using a MySQL database, Java's Spring framework, Coldfusion and Javascript to an MSSQL database, and C# and VB off another MSSQL database. Primarily, I've developed for Linux platforms, but at my current position, I am the sole developer and maintainer of the C# and VB applications on Windows.
    * Personally, I have written major projects in Python and Rust, interacting with MySQL and sqlite3 databases and dozens of web APIs.
    * In school, I wrote an enormous amount of code in C/C++, including more toy programs, all the way up to compilers and a 'hobby' operating system based off Harvard's OS 161 course.
  - Would you describe yourself as a strong coder? Why?
    * I'm not a rockstar unicorn developer, but I do think I have unicorn breadth of knowledge. I'm a moderately strong pure programmer, but my understanding of a wide variety of systems and strong networking knowledge can lead to clever solutions. 
    * TODO XXX FIXME
  - Would you describe yourself as a strong architect? If so, why, and in which sorts of applications?
    * I'm alright as an architect. I can identify poor patterns pretty well, though; parts of an application changing other areas without going through an interface or method, for example. I have personally rewritten components of software where the code that made the SQL calls was directly modifying the view, instead of simply returning updated row information to the view, which did the update itself. I also look out for situations in which algorithms are expensive or inefficient (big O).
  - Outline your thoughts on open source software development. What is important to get right in open source projects?
    * Very very first, it has to solve a problem. Then, very close second, it has to be easily installed, and very very close third, it needs sane defaults and useage. Documentation is enormously important, both for luring contributors (API documentation) and users (real-world examples of use cases, with flags, configuration paths, etc).
    * If a tool already exists to solve a problem but is hard to install and esoteric to use, someone will come up with an alternative, often using lessons learned creating the first. User experience is so important. You can be good or you can be easy - a niche exists for either - but to be both is best.
  - What open source projects have you worked on?
    * I've contributed to the VyOS open-source routing projects (based on Debian); in fact, when the VyOS project had first been forked from Vyatta, they opened up a donation option - I was the very first regular donor. I contributed to IPv6 DHCP prefix delegation bug fixes, troubleshooting, and documentation, specifically in the strange behavior of Comcast business modems handing out IPv6 prefixes when also doing static IPv4 routing.
    * I've contributed to i3status-rs (an i3 status bar in rust), the qtile tiling window manager (in python), and added support for isc-dhcp-server to perform dnsupdates to a server off the standard DNS port in C. Unfortunately that last one wasn't merged, as future ISC development work was focused on Koa, their followup DHCP server.
    * Personally, I've written an IRC bot in python, a dotfile manager with dependency-resolution in rust, and a DHCP server, also in rust.
  - Have you been an open source maintainer? On which projects, and what was your role?
    * For my own projects, I'm the maintainer; I worked briefly with the packager and maintainer of the wireguard/wireguard-tools package on Debian (Daniel Kahn Gilmore).

Education
=========

  - How did you fare in high school mathematics, physical sciences and computing? Which were strengths and which were most enjoyable? How did you rank, competitively, in them?
    * In high school I was an OK student at math but an excellent student at physical sciences and computing. In computing, I was a top 5% student, and in physics, probably top 15-25%. I understood better when the math could be applied. I absolutely adored physics and computing, and in fact junior/senior years, assisted the IT staff in setup and security of the systems and network for my school.
  - Which degree and university did you choose, and why?
    * I was a little directionless leaving high school, definitely not uniquely, and 'computer science' had 'computer' in the name, so I declared for a computer science bachelor's degree at Chico State. Chico was close enough, I actually really liked the town and the campus, and the computer science program was unexpectedly very well regarded.
    * I briefly flirted with a physics degree, but that notion disappeared when I got into more difficult and interesting CSCI classes. I had a particular teacher at my university, Tyson Henry, who taught with passion and energy, and in whose office I spent many a darkening evening trying to get over a conceptual hump. I sent him an email at 1 am on a Saturday detailing difficulty I was having with one part of an assignement, and he responded at 1:30. He cared, and would dedicate enormous amounts of time and energy to students who really wanted to learn.
  - Which university courses did you perform best at? How did you rank in your degree?
    * I was best at the operating systems course, where we built a toy kernel in C. That class was incredibly difficult and rewarding, as was compiler design, where we wrote a compiler for a toy game developement language. I didn't have any classes on Linux itself, though all our development was done on Linux systems. On nights and weekends, I taught myself Linux, running web and SMTP services, annoyed my roommates flashing new firmwares on our router, and running into and resolving bugs with Bluetooth on my Macbook Pro 3,1 running Ubuntu 7.04, 7.10, 8.04...
    * Outside of my major, I was in an honors program to complete most of my general education requirements, and I did pretty well in that. It was a very small class; only about 40 students, and I was maybe top 30-40%. I've always read very quickly, had good comprehension, and been a decent writer, and since those classes were heavy on those things, I did pretty well.
  - What did you achieve in high school or university that you consider exceptional?
    * In university I was part of the Chico State Linux User's Group, and was one of the most knowledgeable. I did give several presentations, themed around intending to show how simple core services could be to set up, outlining gotchas and the important security concerns. I also ran the IRC server for CSLUG.
    * I discovered and reported several security flaws in the student shared Linux servers, specifically the ability to access other users' tmp files, and a lack of restriction on individual users' use of CPU time.

Context
=======

  - How comprehensive would you say your knowledge of a Linux distribution is, from the kernel up? How familiar are you with low-level system architecture, runtimes and Linux distro packaging? How have you gained this knowledge?
    * My knowledge of a Linux distribution varies at level. I can debug kernel issues pretty well, understand roughly how the system boots (bootloader, initramfs), and how display protocols like X and Wayland work (I tend to run sway/wlroots from source). I understand packaging decently well (very familiar with apt). I've gained this knowledge from trying to install alien packages on Debian/Ubuntu systems :), and from building my own deb packages.
  - Outline your thoughts on quality in software development. What practices are most effective to drive improvements in quality?
    * Quality is kind of a tough metric. Performance is one, user experience is another, resilience, expandability, maintenance cost (time and money), etc. I think when initially writing an application, getting an understanding of how to solve the problem is absolutely crucial - build a working prototype right away. Doing so, you'll discover the actual flow of data, what the input data looks like, the transformations you'll have to do to make it output the intended result. Then rewrite it with what you've learned. Especially early on, restarting with your new knowledge is less costly than trying to build the entire thing, and *then* rewriting it. Essentially, iterating quickly.
    * If you're not the end user, understanding the end user's needs and environment is crucial. I personally work with a couple 'superusers' for the software I maintain at work, and often connect with them to directly watch how they use the software in their real world. You learn how someone understands your application's features; you can change the workflow or provide training, explain features that can alleviate pain, and discover bugs in your testing; for example, when testing, you doesn't print multiple labels, then print multiple labels for a second patient.
  - Describe your experience of continuous integration and testing. What tools and processes do you think are relevant to Ubuntu quality?
    * I've used Jenkins and GitHub workflows for CI and library testing (I can also say that Rust's cargo test is astonishingly valuable). CI is crucial for knowing if a library update can be done without fear or if it'll break your build - but it's only as good as the tests you've written. If you haven't written a test for each function or component, you won't know if changes will break your build.
    * Honestly, I haven't experienced a lot of bugs on Ubuntu, especially on Ubuntu's prescribed DEs. I usually run into problems when assembling my own desktop environment/WM, but even those aren't bugs. Ubuntu has occasionally 'backed the wrong horse' when it comes to a new technology, such as Mir, and generated some complaints with `snap`. It might not be as appealing, but backing existing projects that do roughly what you're intending, instead of starting new, could be a better use of Ubuntu's time.
  - Outline your thoughts on the mission of Canonical. What is it about the company's purpose and goals which is most appealing to you? What is risky or unappealing?
    *
  - Who are Canonical's key competitors, and how should Canonical set about winning?
    * Red Hat's the obvious answer, but Canonical and Red Hat are sort of aiming at different niches - Ubuntu more at the destop world, and Red Hat at the enterprise server. The real competitor for Canonical is Microsoft and Windows. There is a great opportunity for Canonical to offer a competitor to the current push by MS for Windows as a service. People were happier to buy Windows once and then own and control it. Recently, MS has removed control over a variety of *oh so trivial things* (sarcasm) like when to reboot, updates applying on their own, and (less troubling but still annoying) their browser begging and pleading to be set as default. If Ubuntu worked with Valve, for example, to create a desktop Linux with excellent graphics support, really sold it as a viable Windows replacement, without losing gaming or Office or Photoshop, people would absolutely switch. Free as in free vs paying a subscription sells a lot of copies. My wife, who's tech savvy and a power user but not in IT, hates hates hates how Windows reboots on its own. She has lost work, but is more incensed by the fact that it decided to reboot without her consent.
  - Why do you most want to work for Canonical?
    * Deeply passionate about open source and empowering users with the rights to their own stuff. Canonical is a company whose entire product is open source, and who is big enough to be a stable employer. I think I'd get real opportunities to work on stuff that is both fun on its own and morally valuable, and with people who are also excited about making good software and improving the world with it.
  - What would you most want to change about Canonical?
    * I don't know enough about Canonical to know what I think should be changed.

